<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Gym Character Animation Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 300px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #64b5f6;
        }
        
        .control-group input, .control-group button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        button {
            background: linear-gradient(to right, #4CAF50, #2E7D32);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background: linear-gradient(to right, #45a049, #1B5E20);
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #info div {
            margin-bottom: 5px;
        }
        
        #info span {
            color: #64b5f6;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }
        
        #loading::after {
            content: "";
            display: block;
            width: 50px;
            height: 50px;
            margin: 20px auto;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #fileInput {
            display: none;
        }
        
        #fileInputLabel {
            display: block;
            background: linear-gradient(to right, #2196F3, #0D47A1);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        #fileInputLabel:hover {
            background: linear-gradient(to right, #0b7dda, #082f6e);
            transform: translateY(-2px);
        }
        
        #title {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }
        
        #title span {
            color: #4CAF50;
            display: block;
            font-size: 16px;
            margin-top: 5px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="title">Gym Animation Viewer<span>Enhanced Character Model</span></div>
        <div id="loading">Loading Enhanced Character Model...</div>
        
        <div id="controls">
            <div class="control-group">
                <input type="file" id="fileInput" accept=".csv">
                <label for="fileInput" id="fileInputLabel">Load CSV File</label>
            </div>
            
            <div class="control-group">
                <label>Animation Control</label>
                <button id="playBtn">▶ Play Animation</button>
                <button id="pauseBtn" disabled>⏸ Pause</button>
                <button id="resetBtn">↺ Reset</button>
            </div>
            
            <div class="control-group">
                <label for="speedSlider">Animation Speed: <span id="speedValue">1.0x</span></label>
                <input type="range" id="speedSlider" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label for="frameSlider">Frame: <span id="frameValue">0</span></label>
                <input type="range" id="frameSlider" min="0" max="21" step="1" value="0" disabled>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showKeypoints"> Show Keypoints
                </label>
            </div>
        </div>
        
        <div id="info">
            <div>Frame: <span id="currentFrame">0</span>/<span id="totalFrames">0</span></div>
            <div>Time: <span id="currentTime">0.0</span>s</div>
            <div>Confidence: <span id="avgConfidence">0.0</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Three.js Setup
        let scene, camera, renderer, human, keypointSpheres = [];
        let isPlaying = false, currentFrame = 0, animationSpeed = 1.0;
        let frameSlider, speedSlider, showKeypointsCheckbox;
        let animationData = [];
        let maxFrames = 0;
        let controls;

        // Animation variables
        let lastTime = 0;
        const frameDuration = 100; // milliseconds per frame

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.03);

            // Camera setup - make it orbitable
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 5);
            camera.lookAt(0, 1, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 3;
            controls.maxDistance = 15;
            controls.maxPolarAngle = Math.PI * 0.9;

            // Lighting - enhanced gym lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Main directional light (like ceiling lights)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 5, 0);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            // Additional lights for gym ambiance
            const pointLight1 = new THREE.PointLight(0xffaa33, 0.5, 15);
            pointLight1.position.set(3, 3, 3);
            pointLight1.castShadow = true;
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x33aaff, 0.5, 15);
            pointLight2.position.set(-3, 3, -3);
            pointLight2.castShadow = true;
            scene.add(pointLight2);

            // Create gym environment
            createGymEnvironment();

            // Create enhanced human character
            createHumanCharacter();

            // Setup controls
            setupControls();

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Start render loop
            animate();
        }

        function createGymEnvironment() {
            // Gym floor
            const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(10, 10);
            floorTexture.anisotropy = 16;
            
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Gym walls
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 5),
                wallMaterial
            );
            backWall.position.z = -10;
            backWall.position.y = 2.5;
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Side walls
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 5),
                wallMaterial
            );
            leftWall.position.x = -10;
            leftWall.position.y = 2.5;
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 5),
                wallMaterial
            );
            rightWall.position.x = 10;
            rightWall.position.y = 2.5;
            rightWall.rotation.y = Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // Gym equipment (simple representations)
            // Weight rack
            const rackMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.8
            });
            
            const rackBase = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.1, 3),
                rackMaterial
            );
            rackBase.position.set(5, 0.05, -5);
            rackBase.castShadow = true;
            rackBase.receiveShadow = true;
            scene.add(rackBase);

            const rackPole1 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                rackMaterial
            );
            rackPole1.position.set(5.5, 0.8, -5);
            rackPole1.castShadow = true;
            scene.add(rackPole1);

            const rackPole2 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                rackMaterial
            );
            rackPole2.position.set(4.5, 0.8, -5);
            rackPole2.castShadow = true;
            scene.add(rackPole2);

            // Add some weight plates
            for (let i = 0; i < 3; i++) {
                const weight = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16),
                    new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        roughness: 0.3,
                        metalness: 0.9
                    })
                );
                weight.position.set(5.5, 0.1 + i * 0.11, -5.5);
                weight.rotation.x = Math.PI / 2;
                weight.castShadow = true;
                scene.add(weight);
            }

            // Mirror wall
            const mirrorMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.1,
                metalness: 0.9,
                envMap: null // In a real scene you'd add an environment map here
            });
            
            const mirror = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 3),
                mirrorMaterial
            );
            mirror.position.set(0, 1.5, -9.9);
            mirror.receiveShadow = true;
            scene.add(mirror);

            // Add some gym mats
            const matMaterial = new THREE.MeshStandardMaterial({
                color: 0x006600,
                roughness: 0.9,
                metalness: 0
            });
            
            const mat = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 6),
                matMaterial
            );
            mat.position.set(0, 0.05, 4);
            mat.castShadow = true;
            mat.receiveShadow = true;
            scene.add(mat);
        }

        function createHumanCharacter() {
            human = new THREE.Group();
            human.name = 'humanCharacter';

            // Enhanced character materials
            const skinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffdbac,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const shirtMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2E7D32, // Green shirt
                roughness: 0.8,
                metalness: 0.1
            });
            
            const pantsMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1565C0, // Blue pants
                roughness: 0.8,
                metalness: 0.1
            });
            
            const shoeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x212121, // Black shoes
                roughness: 0.5,
                metalness: 0.5
            });
            
            const jointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff6b6b,
                roughness: 0.3,
                metalness: 0.3
            });

            // Enhanced body parts geometry
            const headGeometry = new THREE.SphereGeometry(0.22, 32, 32);
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 16);
            const upperArmGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 16);
            const forearmGeometry = new THREE.CylinderGeometry(0.07, 0.08, 0.5, 16);
            const thighGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.7, 16);
            const shinGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.7, 16);
            const footGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
            const jointGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const handGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.15);

            // Create enhanced body parts
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.name = 'head';
            head.position.y = 1.65;
            head.castShadow = true;
            
            // Add facial features to the head
            const eyeGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 0.05, 0.22);
            head.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 0.05, 0.22);
            head.add(rightEye);
            
            const mouthGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.01);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.1, 0.22);
            head.add(mouth);
            
            // Add hair
            const hairGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 32);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0.15;
            head.add(hair);
            
            human.add(head);

            // Enhanced torso with muscle definition
            const torso = new THREE.Mesh(bodyGeometry, shirtMaterial);
            torso.name = 'torso';
            torso.position.y = 0.9;
            torso.castShadow = true;
            human.add(torso);

            // Arms with detailed hands
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, shirtMaterial);
            leftUpperArm.name = 'leftUpperArm';
            leftUpperArm.position.set(-0.4, 1.0, 0);
            leftUpperArm.castShadow = true;
            human.add(leftUpperArm);

            const rightUpperArm = new THREE.Mesh(upperArmGeometry, shirtMaterial);
            rightUpperArm.name = 'rightUpperArm';
            rightUpperArm.position.set(0.4, 1.0, 0);
            rightUpperArm.castShadow = true;
            human.add(rightUpperArm);

            const leftForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
            leftForearm.name = 'leftForearm';
            leftForearm.position.set(-0.8, 0.6, 0);
            leftForearm.castShadow = true;
            human.add(leftForearm);

            const rightForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
            rightForearm.name = 'rightForearm';
            rightForearm.position.set(0.8, 0.6, 0);
            rightForearm.castShadow = true;
            human.add(rightForearm);

            // Detailed hands
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.name = 'leftHand';
            leftHand.position.set(-0.9, 0.4, 0);
            leftHand.castShadow = true;
            human.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
            rightHand.name = 'rightHand';
            rightHand.position.set(0.9, 0.4, 0);
            rightHand.castShadow = true;
            human.add(rightHand);

            // Legs with more detailed feet
            const leftThigh = new THREE.Mesh(thighGeometry, pantsMaterial);
            leftThigh.name = 'leftThigh';
            leftThigh.position.set(-0.15, -0.4, 0);
            leftThigh.castShadow = true;
            human.add(leftThigh);

            const rightThigh = new THREE.Mesh(thighGeometry, pantsMaterial);
            rightThigh.name = 'rightThigh';
            rightThigh.position.set(0.15, -0.4, 0);
            rightThigh.castShadow = true;
            human.add(rightThigh);

            const leftShin = new THREE.Mesh(shinGeometry, pantsMaterial);
            leftShin.name = 'leftShin';
            leftShin.position.set(-0.15, -1.15, 0);
            leftShin.castShadow = true;
            human.add(leftShin);

            const rightShin = new THREE.Mesh(shinGeometry, pantsMaterial);
            rightShin.name = 'rightShin';
            rightShin.position.set(0.15, -1.15, 0);
            rightShin.castShadow = true;
            human.add(rightShin);

            // Enhanced shoes
            const leftFoot = new THREE.Mesh(footGeometry, shoeMaterial);
            leftFoot.name = 'leftFoot';
            leftFoot.position.set(-0.15, -1.5, 0.1);
            leftFoot.castShadow = true;
            human.add(leftFoot);

            const rightFoot = new THREE.Mesh(footGeometry, shoeMaterial);
            rightFoot.name = 'rightFoot';
            rightFoot.position.set(0.15, -1.5, 0.1);
            rightFoot.castShadow = true;
            human.add(rightFoot);

            // Add shoe details
            const shoeDetailGeometry = new THREE.BoxGeometry(0.18, 0.02, 0.1);
            const shoeDetailMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
            
            const leftShoeDetail = new THREE.Mesh(shoeDetailGeometry, shoeDetailMaterial);
            leftShoeDetail.position.set(0, 0.05, 0.1);
            leftFoot.add(leftShoeDetail);
            
            const rightShoeDetail = new THREE.Mesh(shoeDetailGeometry, shoeDetailMaterial);
            rightShoeDetail.position.set(0, 0.05, 0.1);
            rightFoot.add(rightShoeDetail);

            // Joints
            const joints = [
                { name: 'leftShoulder', pos: [-0.3, 0.6, 0] },
                { name: 'rightShoulder', pos: [0.3, 0.6, 0] },
                { name: 'leftElbow', pos: [-0.6, 0.1, 0] },
                { name: 'rightElbow', pos: [0.6, 0.1, 0] },
                { name: 'leftWrist', pos: [-0.9, -0.4, 0] },
                { name: 'rightWrist', pos: [0.9, -0.4, 0] },
                { name: 'leftHip', pos: [-0.2, -0.2, 0] },
                { name: 'rightHip', pos: [0.2, -0.2, 0] },
                { name: 'leftKnee', pos: [-0.2, -0.9, 0] },
                { name: 'rightKnee', pos: [0.2, -0.9, 0] },
                { name: 'leftAnkle', pos: [-0.2, -1.7, 0] },
                { name: 'rightAnkle', pos: [0.2, -1.7, 0] }
            ];

            joints.forEach(joint => {
                const jointMesh = new THREE.Mesh(jointGeometry, jointMaterial);
                jointMesh.name = joint.name;
                jointMesh.position.set(...joint.pos);
                jointMesh.castShadow = true;
                human.add(jointMesh);
            });

            scene.add(human);

            // Create keypoint visualization spheres
            createKeypointSpheres();
        }

        function createKeypointSpheres() {
            const keypointMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            const keypointGeometry = new THREE.SphereGeometry(0.05, 16, 16);

            const keypointNames = [
                'leftShoulder', 'rightShoulder', 'leftElbow', 'rightElbow',
                'leftWrist', 'rightWrist', 'leftHip', 'rightHip',
                'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'
            ];

            keypointNames.forEach(name => {
                const sphere = new THREE.Mesh(keypointGeometry, keypointMaterial);
                sphere.name = name + 'Keypoint';
                sphere.visible = false;
                keypointSpheres.push(sphere);
                scene.add(sphere);
            });
        }

        function setupControls() {
            const playBtn = document.getElementById('playBtn');
            const pauseBtn = document.getElementById('pauseBtn');  
            const resetBtn = document.getElementById('resetBtn');
            const fileInput = document.getElementById('fileInput');
            frameSlider = document.getElementById('frameSlider');
            speedSlider = document.getElementById('speedSlider');
            showKeypointsCheckbox = document.getElementById('showKeypoints');

            playBtn.addEventListener('click', startAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            resetBtn.addEventListener('click', resetAnimation);
            
            fileInput.addEventListener('change', handleFileSelect);
            
            frameSlider.addEventListener('input', (e) => {
                currentFrame = parseInt(e.target.value);
                updateHumanPose(currentFrame);
                updateUI();
            });

            speedSlider.addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
            });

            showKeypointsCheckbox.addEventListener('change', (e) => {
                keypointSpheres.forEach(sphere => {
                    sphere.visible = e.target.checked;
                });
            });

            // Initial pose
            updateUI();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    if (results.data && results.data.length > 0) {
                        // Process the CSV data into our animation format
                        animationData = results.data.map(row => {
                            return {
                                frame: row.Frame,
                                timestamp: row.Timestamp,
                                leftShoulder: {x: row.Left_Shoulder_X, y: row.Left_Shoulder_Y, conf: row.Left_Shoulder_Conf},
                                rightShoulder: {x: row.Right_Shoulder_X, y: row.Right_Shoulder_Y, conf: row.Right_Shoulder_Conf},
                                leftElbow: {x: row.Left_Elbow_X, y: row.Left_Elbow_Y, conf: row.Left_Elbow_Conf},
                                rightElbow: {x: row.Right_Elbow_X, y: row.Right_Elbow_Y, conf: row.Right_Elbow_Conf},
                                leftWrist: {x: row.Left_Wrist_X, y: row.Left_Wrist_Y, conf: row.Left_Wrist_Conf},
                                rightWrist: {x: row.Right_Wrist_X, y: row.Right_Wrist_Y, conf: row.Right_Wrist_Conf},
                                leftHip: {x: row.Left_Hip_X, y: row.Left_Hip_Y, conf: row.Left_Hip_Conf},
                                rightHip: {x: row.Right_Hip_X, y: row.Right_Hip_Y, conf: row.Right_Hip_Conf},
                                leftKnee: {x: row.Left_Knee_X, y: row.Left_Knee_Y, conf: row.Left_Knee_Conf},
                                rightKnee: {x: row.Right_Knee_X, y: row.Right_Knee_Y, conf: row.Right_Knee_Conf},
                                leftAnkle: {x: row.Left_Ankle_X, y: row.Left_Ankle_Y, conf: row.Left_Ankle_Conf},
                                rightAnkle: {x: row.Right_Ankle_X, y: row.Right_Ankle_Y, conf: row.Right_Ankle_Conf}
                            };
                        });
                        
                        maxFrames = animationData.length - 1;
                        frameSlider.max = maxFrames;
                        frameSlider.disabled = false;
                        document.getElementById('totalFrames').textContent = maxFrames;
                        
                        // Update to first frame
                        currentFrame = 0;
                        updateHumanPose(0);
                        updateUI();
                    }
                }
            });
        }

        function normalizeCoordinates(x, y) {
            // Convert 2D keypoint coordinates to 3D world coordinates
            // Adjusted to place character slightly above the floor (y=0 is floor level)
            const normalizedX = (x - 691) / 150;
            const normalizedY = -(y - 280) / 150 + 0.8; // Added +0.1 to raise the character
            return { x: normalizedX, y: normalizedY, z: 0 };
        }

        function updateHumanPose(frameIndex) {
            if (!animationData.length || frameIndex >= animationData.length) return;

            const frame = animationData[frameIndex];
            
            // Update human body parts based on keypoints
            const leftShoulderPos = normalizeCoordinates(frame.leftShoulder.x, frame.leftShoulder.y);
            const rightShoulderPos = normalizeCoordinates(frame.rightShoulder.x, frame.rightShoulder.y);
            const leftElbowPos = normalizeCoordinates(frame.leftElbow.x, frame.leftElbow.y);
            const rightElbowPos = normalizeCoordinates(frame.rightElbow.x, frame.rightElbow.y);
            const leftWristPos = normalizeCoordinates(frame.leftWrist.x, frame.leftWrist.y);
            const rightWristPos = normalizeCoordinates(frame.rightWrist.x, frame.rightWrist.y);
            const leftHipPos = normalizeCoordinates(frame.leftHip.x, frame.leftHip.y);
            const rightHipPos = normalizeCoordinates(frame.rightHip.x, frame.rightHip.y);
            const leftKneePos = normalizeCoordinates(frame.leftKnee.x, frame.leftKnee.y);
            const rightKneePos = normalizeCoordinates(frame.rightKnee.x, frame.rightKnee.y);
            const leftAnklePos = normalizeCoordinates(frame.leftAnkle.x, frame.leftAnkle.y);
            const rightAnklePos = normalizeCoordinates(frame.rightAnkle.x, frame.rightAnkle.y);

            // Update joint positions
            const joints = [
                { name: 'leftShoulder', pos: leftShoulderPos },
                { name: 'rightShoulder', pos: rightShoulderPos },
                { name: 'leftElbow', pos: leftElbowPos },
                { name: 'rightElbow', pos: rightElbowPos },
                { name: 'leftWrist', pos: leftWristPos },
                { name: 'rightWrist', pos: rightWristPos },
                { name: 'leftHip', pos: leftHipPos },
                { name: 'rightHip', pos: rightHipPos },
                { name: 'leftKnee', pos: leftKneePos },
                { name: 'rightKnee', pos: rightKneePos },
                { name: 'leftAnkle', pos: leftAnklePos },
                { name: 'rightAnkle', pos: rightAnklePos }
            ];

            // Update human joints
            joints.forEach((joint, index) => {
                const jointMesh = human.getObjectByName(joint.name);
                if (jointMesh) {
                    jointMesh.position.set(joint.pos.x, joint.pos.y, joint.pos.z);
                }

                // Update keypoint spheres
                if (keypointSpheres[index]) {
                    keypointSpheres[index].position.set(joint.pos.x, joint.pos.y, joint.pos.z + 0.1);
                }
            });

            // Update body parts to connect joints smoothly
            updateBodyParts(joints);
        }

        function updateBodyParts(joints) {
            // Get joint positions by name
            const getJointPos = (name) => joints.find(j => j.name === name)?.pos;

            const leftShoulder = getJointPos('leftShoulder');
            const rightShoulder = getJointPos('rightShoulder');
            const leftElbow = getJointPos('leftElbow');
            const rightElbow = getJointPos('rightElbow');
            const leftWrist = getJointPos('leftWrist');
            const rightWrist = getJointPos('rightWrist');
            const leftHip = getJointPos('leftHip');
            const rightHip = getJointPos('rightHip');
            const leftKnee = getJointPos('leftKnee');
            const rightKnee = getJointPos('rightKnee');
            const leftAnkle = getJointPos('leftAnkle');
            const rightAnkle = getJointPos('rightAnkle');

            // Update torso
            const torso = human.getObjectByName('torso');
            if (torso && leftShoulder && rightShoulder && leftHip && rightHip) {
                const centerX = (leftShoulder.x + rightShoulder.x + leftHip.x + rightHip.x) / 4;
                const centerY = (leftShoulder.y + rightShoulder.y + leftHip.y + rightHip.y) / 4;
                torso.position.set(centerX, centerY, 0);
            }

            // Update head
            const head = human.getObjectByName('head');
            if (head && leftShoulder && rightShoulder) {
                const headX = (leftShoulder.x + rightShoulder.x) / 2;
                const headY = (leftShoulder.y + rightShoulder.y) / 2 + 0.3;
                head.position.set(headX, headY, 0);
            }

            // Update arms
            updateLimb('leftUpperArm', leftShoulder, leftElbow);
            updateLimb('rightUpperArm', rightShoulder, rightElbow);
            updateLimb('leftForearm', leftElbow, leftWrist);
            updateLimb('rightForearm', rightElbow, rightWrist);

            // Update legs
            updateLimb('leftThigh', leftHip, leftKnee);
            updateLimb('rightThigh', rightHip, rightKnee);
            updateLimb('leftShin', leftKnee, leftAnkle);
            updateLimb('rightShin', rightKnee, rightAnkle);
            
            // Update feet
            const leftFoot = human.getObjectByName('leftFoot');
            if (leftFoot && leftAnkle) {
                leftFoot.position.set(leftAnkle.x, leftAnkle.y - 0.15, leftAnkle.z + 0.1);
            }
            
            const rightFoot = human.getObjectByName('rightFoot');
            if (rightFoot && rightAnkle) {
                rightFoot.position.set(rightAnkle.x, rightAnkle.y - 0.15, rightAnkle.z + 0.1);
            }
            
            // Update hands
            const leftHand = human.getObjectByName('leftHand');
            if (leftHand && leftWrist) {
                leftHand.position.set(leftWrist.x, leftWrist.y, leftWrist.z);
            }
            
            const rightHand = human.getObjectByName('rightHand');
            if (rightHand && rightWrist) {
                rightHand.position.set(rightWrist.x, rightWrist.y, rightWrist.z);
            }
        }

        function updateLimb(limbName, startPos, endPos) {
            const limb = human.getObjectByName(limbName);
            if (!limb || !startPos || !endPos) return;

            // Position limb at midpoint
            const midX = (startPos.x + endPos.x) / 2;
            const midY = (startPos.y + endPos.y) / 2;
            const midZ = (startPos.z + endPos.z) / 2;
            limb.position.set(midX, midY, midZ);

            // Rotate limb to align with start and end points
            const direction = new THREE.Vector3(
                endPos.x - startPos.x,
                endPos.y - startPos.y,
                endPos.z - startPos.z
            );
            const length = direction.length();
            
            if (length > 0) {
                direction.normalize();
                
                // Calculate rotation to align with direction
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, direction);
                limb.setRotationFromQuaternion(quaternion);
                
                // Scale limb to match distance
                if (limbName.includes('UpperArm') || limbName.includes('Forearm')) {
                    limb.scale.y = length / 0.5; // Original arm length is 0.5
                } else if (limbName.includes('Thigh') || limbName.includes('Shin')) {
                    limb.scale.y = length / 0.7; // Original leg length is 0.7
                }
            }
        }

        function startAnimation() {
            if (!animationData.length) return;
            
            isPlaying = true;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            lastTime = performance.now();
        }

        function pauseAnimation() {
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        }

        function resetAnimation() {
            isPlaying = false;
            currentFrame = 0;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (animationData.length) {
                updateHumanPose(0);
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('frameValue').textContent = currentFrame;
            document.getElementById('currentFrame').textContent = currentFrame;
            document.getElementById('currentTime').textContent = (currentFrame * 0.1).toFixed(1);
            
            if (animationData.length && currentFrame < animationData.length) {
                const frame = animationData[currentFrame];
                const avgConf = [
                    frame.leftShoulder.conf, frame.rightShoulder.conf,
                    frame.leftElbow.conf, frame.rightElbow.conf,
                    frame.leftWrist.conf, frame.rightWrist.conf,
                    frame.leftHip.conf, frame.rightHip.conf,
                    frame.leftKnee.conf, frame.rightKnee.conf,
                    frame.leftAnkle.conf, frame.rightAnkle.conf
                ].reduce((a, b) => a + b) / 12;
                
                document.getElementById('avgConfidence').textContent = avgConf.toFixed(3);
            }
            
            frameSlider.value = currentFrame;
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (isPlaying && animationData.length && currentTime - lastTime >= frameDuration / animationSpeed) {
                currentFrame++;
                if (currentFrame >= animationData.length) {
                    resetAnimation();
                } else {
                    updateHumanPose(currentFrame);
                    updateUI();
                    lastTime = currentTime;
                }
            }

            // Update orbit controls
            if (controls) {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the application
        init();
    </script>
</body>
</html>